'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var reactflow = require('reactflow');
var pathfinding = require('pathfinding');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

var getNextPointFromPosition = function getNextPointFromPosition(point, position) {
  switch (position) {
    case 'top':
      return {
        x: point.x,
        y: point.y - 1
      };
    case 'bottom':
      return {
        x: point.x,
        y: point.y + 1
      };
    case 'left':
      return {
        x: point.x - 1,
        y: point.y
      };
    case 'right':
      return {
        x: point.x + 1,
        y: point.y
      };
  }
};
/**
 * Guarantee that the path is walkable, even if the point is inside a non
 * walkable area, by adding a walkable path in the direction of the point's
 * Position.
 */
var guaranteeWalkablePath = function guaranteeWalkablePath(grid, point, position) {
  var node = grid.getNodeAt(point.x, point.y);
  while (!node.walkable) {
    grid.setWalkableAt(node.x, node.y, true);
    var next = getNextPointFromPosition(node, position);
    node = grid.getNodeAt(next.x, next.y);
  }
};

/**
 * Each bounding box is a collection of X/Y points in a graph, and we
 * need to convert them to "occupied" cells in a 2D grid representation.
 *
 * The top most position of the grid (grid[0][0]) needs to be equivalent
 * to the top most point in the graph (the graph.topLeft point).
 *
 * Since the top most point can have X/Y values different than zero,
 * and each cell in a grid represents a 10x10 pixel area in the grid (or a
 * gridRatio area), there's need to be a conversion between a point in a graph
 * to a point in the grid.
 *
 * We do this conversion by dividing a graph point X/Y values by the grid ratio,
 * and "shifting" their values up or down, depending on the values of the top
 * most point in the graph. The top most point in the graph will have the
 * smallest values for X and Y.
 *
 * We avoid setting nodes in the border of the grid (x=0 or y=0), so there's
 * always a "walkable" area around the grid.
 */
var graphToGridPoint = function graphToGridPoint(graphPoint, smallestX, smallestY, gridRatio) {
  var x = graphPoint.x / gridRatio;
  var y = graphPoint.y / gridRatio;
  var referenceX = smallestX / gridRatio;
  var referenceY = smallestY / gridRatio;
  if (referenceX < 1) {
    while (referenceX !== 1) {
      referenceX++;
      x++;
    }
  } else if (referenceX > 1) {
    while (referenceX !== 1) {
      referenceX--;
      x--;
    }
  } else ;
  if (referenceY < 1) {
    while (referenceY !== 1) {
      referenceY++;
      y++;
    }
  } else if (referenceY > 1) {
    while (referenceY !== 1) {
      referenceY--;
      y--;
    }
  } else ;
  return {
    x: x,
    y: y
  };
};
/**
 * Converts a grid point back to a graph point, using the reverse logic of
 * graphToGridPoint.
 */
var gridToGraphPoint = function gridToGraphPoint(gridPoint, smallestX, smallestY, gridRatio) {
  var x = gridPoint.x * gridRatio;
  var y = gridPoint.y * gridRatio;
  var referenceX = smallestX;
  var referenceY = smallestY;
  if (referenceX < gridRatio) {
    while (referenceX !== gridRatio) {
      referenceX = referenceX + gridRatio;
      x = x - gridRatio;
    }
  } else if (referenceX > gridRatio) {
    while (referenceX !== gridRatio) {
      referenceX = referenceX - gridRatio;
      x = x + gridRatio;
    }
  } else ;
  if (referenceY < gridRatio) {
    while (referenceY !== gridRatio) {
      referenceY = referenceY + gridRatio;
      y = y - gridRatio;
    }
  } else if (referenceY > gridRatio) {
    while (referenceY !== gridRatio) {
      referenceY = referenceY - gridRatio;
      y = y + gridRatio;
    }
  } else ;
  return {
    x: x,
    y: y
  };
};

var round = function round(x, multiple) {
  if (multiple === void 0) {
    multiple = 10;
  }
  return Math.round(x / multiple) * multiple;
};
var roundDown = function roundDown(x, multiple) {
  if (multiple === void 0) {
    multiple = 10;
  }
  return Math.floor(x / multiple) * multiple;
};
var roundUp = function roundUp(x, multiple) {
  if (multiple === void 0) {
    multiple = 10;
  }
  return Math.ceil(x / multiple) * multiple;
};
var toInteger = function toInteger(value, min) {
  if (min === void 0) {
    min = 0;
  }
  var result = Math.max(Math.round(value), min);
  result = Number.isInteger(result) ? result : min;
  result = result >= min ? result : min;
  return result;
};

var createGrid = function createGrid(graph, nodes, source, target, gridRatio) {
  if (gridRatio === void 0) {
    gridRatio = 2;
  }
  var xMin = graph.xMin,
    yMin = graph.yMin,
    width = graph.width,
    height = graph.height;
  // Create a grid representation of the graph box, where each cell is
  // equivalent to 10x10 pixels (or the grid ratio) on the graph. We'll use
  // this simplified grid to do pathfinding.
  var mapColumns = roundUp(width, gridRatio) / gridRatio + 1;
  var mapRows = roundUp(height, gridRatio) / gridRatio + 1;
  var grid = new pathfinding.Grid(mapColumns, mapRows);
  // Update the grid representation with the space the nodes take up
  nodes.forEach(function (node) {
    var nodeStart = graphToGridPoint(node.topLeft, xMin, yMin, gridRatio);
    var nodeEnd = graphToGridPoint(node.bottomRight, xMin, yMin, gridRatio);
    for (var x = nodeStart.x; x < nodeEnd.x; x++) {
      for (var y = nodeStart.y; y < nodeEnd.y; y++) {
        grid.setWalkableAt(x, y, false);
      }
    }
  });
  // Convert the starting and ending graph points to grid points
  var startGrid = graphToGridPoint({
    x: round(source.x, gridRatio),
    y: round(source.y, gridRatio)
  }, xMin, yMin, gridRatio);
  var endGrid = graphToGridPoint({
    x: round(target.x, gridRatio),
    y: round(target.y, gridRatio)
  }, xMin, yMin, gridRatio);
  // Guarantee a walkable path between the start and end points, even if the
  // source or target where covered by another node or by padding
  var startingNode = grid.getNodeAt(startGrid.x, startGrid.y);
  guaranteeWalkablePath(grid, startingNode, source.position);
  var endingNode = grid.getNodeAt(endGrid.x, endGrid.y);
  guaranteeWalkablePath(grid, endingNode, target.position);
  // Use the next closest points as the start and end points, so
  // pathfinding does not start too close to the nodes
  var start = getNextPointFromPosition(startingNode, source.position);
  var end = getNextPointFromPosition(endingNode, target.position);
  return {
    grid: grid,
    start: start,
    end: end
  };
};

/**
 * Draws a SVG path from a list of points, using straight lines.
 */
var svgDrawStraightLinePath = function svgDrawStraightLinePath(source, target, path) {
  var svgPathString = "M " + source.x + ", " + source.y + " ";
  path.forEach(function (point) {
    var x = point[0],
      y = point[1];
    svgPathString += "L " + x + ", " + y + " ";
  });
  svgPathString += "L " + target.x + ", " + target.y + " ";
  return svgPathString;
};
/**
 * Draws a SVG path from a list of points, using rounded lines.
 */
var svgDrawSmoothLinePath = function svgDrawSmoothLinePath(source, target, path) {
  var points = [[source.x, source.y]].concat(path, [[target.x, target.y]]);
  return quadraticBezierCurve(points);
};
var quadraticBezierCurve = function quadraticBezierCurve(points) {
  var X = 0;
  var Y = 1;
  var point = points[0];
  var first = points[0];
  var svgPath = "M" + first[X] + "," + first[Y] + "M";
  for (var i = 0; i < points.length; i++) {
    var next = points[i];
    var midPoint = getMidPoint(point[X], point[Y], next[X], next[Y]);
    svgPath += " " + midPoint[X] + "," + midPoint[Y];
    svgPath += "Q" + next[X] + "," + next[Y];
    point = next;
  }
  var last = points[points.length - 1];
  svgPath += " " + last[0] + "," + last[1];
  return svgPath;
};
var getMidPoint = function getMidPoint(Ax, Ay, Bx, By) {
  var Zx = (Ax - Bx) / 2 + Bx;
  var Zy = (Ay - By) / 2 + By;
  return [Zx, Zy];
};

// FIXME: The "pathfinding" module doe not have proper typings.
var pathfindingAStarDiagonal = function pathfindingAStarDiagonal(grid, start, end) {
  try {
    var finder = new pathfinding.AStarFinder({
      diagonalMovement: pathfinding.DiagonalMovement.Always
    });
    var fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid);
    var smoothedPath = pathfinding.Util.smoothenPath(grid, fullPath);
    if (fullPath.length === 0 || smoothedPath.length === 0) return null;
    return {
      fullPath: fullPath,
      smoothedPath: smoothedPath
    };
  } catch (_unused) {
    return null;
  }
};
var pathfindingAStarNoDiagonal = function pathfindingAStarNoDiagonal(grid, start, end) {
  try {
    var finder = new pathfinding.AStarFinder({
      diagonalMovement: pathfinding.DiagonalMovement.Never
    });
    var fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid);
    var smoothedPath = pathfinding.Util.smoothenPath(grid, fullPath);
    if (fullPath.length === 0 || smoothedPath.length === 0) return null;
    return {
      fullPath: fullPath,
      smoothedPath: smoothedPath
    };
  } catch (_unused2) {
    return null;
  }
};
var pathfindingJumpPointNoDiagonal = function pathfindingJumpPointNoDiagonal(grid, start, end) {
  try {
    // FIXME: The "pathfinding" module doe not have proper typings.
    // @ts-ignore
    var finder = new pathfinding.JumpPointFinder({
      diagonalMovement: pathfinding.DiagonalMovement.Never
    });
    var fullPath = finder.findPath(start.x, start.y, end.x, end.y, grid);
    var smoothedPath = fullPath;
    if (fullPath.length === 0 || smoothedPath.length === 0) return null;
    return {
      fullPath: fullPath,
      smoothedPath: smoothedPath
    };
  } catch (_unused3) {
    return null;
  }
};

/**
 * Get the bounding box of all nodes and the graph itself, as X/Y coordinates
 * of all corner points.
 *
 * @param nodes The node list
 * @param nodePadding Optional padding to add to the node's and graph bounding boxes
 * @param roundTo Everything will be rounded to this nearest integer
 * @returns Graph and nodes bounding boxes.
 */
var getBoundingBoxes = function getBoundingBoxes(nodes, nodePadding, roundTo) {
  if (nodePadding === void 0) {
    nodePadding = 2;
  }
  if (roundTo === void 0) {
    roundTo = 2;
  }
  var xMax = Number.MIN_SAFE_INTEGER;
  var yMax = Number.MIN_SAFE_INTEGER;
  var xMin = Number.MAX_SAFE_INTEGER;
  var yMin = Number.MAX_SAFE_INTEGER;
  var nodeBoxes = nodes.map(function (node) {
    var _node$positionAbsolut, _node$positionAbsolut2;
    var width = Math.max(node.width || 0, 1);
    var height = Math.max(node.height || 0, 1);
    var position = {
      x: ((_node$positionAbsolut = node.positionAbsolute) == null ? void 0 : _node$positionAbsolut.x) || 0,
      y: ((_node$positionAbsolut2 = node.positionAbsolute) == null ? void 0 : _node$positionAbsolut2.y) || 0
    };
    var topLeft = {
      x: position.x - nodePadding,
      y: position.y - nodePadding
    };
    var bottomLeft = {
      x: position.x - nodePadding,
      y: position.y + height + nodePadding
    };
    var topRight = {
      x: position.x + width + nodePadding,
      y: position.y - nodePadding
    };
    var bottomRight = {
      x: position.x + width + nodePadding,
      y: position.y + height + nodePadding
    };
    if (roundTo > 0) {
      topLeft.x = roundDown(topLeft.x, roundTo);
      topLeft.y = roundDown(topLeft.y, roundTo);
      bottomLeft.x = roundDown(bottomLeft.x, roundTo);
      bottomLeft.y = roundUp(bottomLeft.y, roundTo);
      topRight.x = roundUp(topRight.x, roundTo);
      topRight.y = roundDown(topRight.y, roundTo);
      bottomRight.x = roundUp(bottomRight.x, roundTo);
      bottomRight.y = roundUp(bottomRight.y, roundTo);
    }
    if (topLeft.y < yMin) yMin = topLeft.y;
    if (topLeft.x < xMin) xMin = topLeft.x;
    if (bottomRight.y > yMax) yMax = bottomRight.y;
    if (bottomRight.x > xMax) xMax = bottomRight.x;
    return {
      id: node.id,
      width: width,
      height: height,
      topLeft: topLeft,
      bottomLeft: bottomLeft,
      topRight: topRight,
      bottomRight: bottomRight
    };
  });
  var graphPadding = nodePadding * 2;
  xMax = roundUp(xMax + graphPadding, roundTo);
  yMax = roundUp(yMax + graphPadding, roundTo);
  xMin = roundDown(xMin - graphPadding, roundTo);
  yMin = roundDown(yMin - graphPadding, roundTo);
  var topLeft = {
    x: xMin,
    y: yMin
  };
  var bottomLeft = {
    x: xMin,
    y: yMax
  };
  var topRight = {
    x: xMax,
    y: yMin
  };
  var bottomRight = {
    x: xMax,
    y: yMax
  };
  var width = Math.abs(topLeft.x - topRight.x);
  var height = Math.abs(topLeft.y - bottomLeft.y);
  var graphBox = {
    topLeft: topLeft,
    bottomLeft: bottomLeft,
    topRight: topRight,
    bottomRight: bottomRight,
    width: width,
    height: height,
    xMax: xMax,
    yMax: yMax,
    xMin: xMin,
    yMin: yMin
  };
  return {
    nodeBoxes: nodeBoxes,
    graphBox: graphBox
  };
};

var getSmartEdge = function getSmartEdge(_ref) {
  var _ref$options = _ref.options,
    options = _ref$options === void 0 ? {} : _ref$options,
    _ref$nodes = _ref.nodes,
    nodes = _ref$nodes === void 0 ? [] : _ref$nodes,
    sourceX = _ref.sourceX,
    sourceY = _ref.sourceY,
    targetX = _ref.targetX,
    targetY = _ref.targetY,
    sourcePosition = _ref.sourcePosition,
    targetPosition = _ref.targetPosition;
  try {
    var _options$drawEdge = options.drawEdge,
      drawEdge = _options$drawEdge === void 0 ? svgDrawSmoothLinePath : _options$drawEdge,
      _options$generatePath = options.generatePath,
      generatePath = _options$generatePath === void 0 ? pathfindingAStarDiagonal : _options$generatePath;
    var _options$gridRatio = options.gridRatio,
      gridRatio = _options$gridRatio === void 0 ? 10 : _options$gridRatio,
      _options$nodePadding = options.nodePadding,
      nodePadding = _options$nodePadding === void 0 ? 10 : _options$nodePadding;
    gridRatio = toInteger(gridRatio);
    nodePadding = toInteger(nodePadding);
    // We use the node's information to generate bounding boxes for them
    // and the graph
    var _getBoundingBoxes = getBoundingBoxes(nodes, nodePadding, gridRatio),
      graphBox = _getBoundingBoxes.graphBox,
      nodeBoxes = _getBoundingBoxes.nodeBoxes;
    var source = {
      x: sourceX,
      y: sourceY,
      position: sourcePosition
    };
    var target = {
      x: targetX,
      y: targetY,
      position: targetPosition
    };
    // With this information, we can create a 2D grid representation of
    // our graph, that tells us where in the graph there is a "free" space or not
    var _createGrid = createGrid(graphBox, nodeBoxes, source, target, gridRatio),
      grid = _createGrid.grid,
      start = _createGrid.start,
      end = _createGrid.end;
    // We then can use the grid representation to do pathfinding
    var generatePathResult = generatePath(grid, start, end);
    if (generatePathResult === null) {
      return null;
    }
    var fullPath = generatePathResult.fullPath,
      smoothedPath = generatePathResult.smoothedPath;
    // Here we convert the grid path to a sequence of graph coordinates.
    var graphPath = smoothedPath.map(function (gridPoint) {
      var x = gridPoint[0],
        y = gridPoint[1];
      var graphPoint = gridToGraphPoint({
        x: x,
        y: y
      }, graphBox.xMin, graphBox.yMin, gridRatio);
      return [graphPoint.x, graphPoint.y];
    });
    // Finally, we can use the graph path to draw the edge
    var svgPathString = drawEdge(source, target, graphPath);
    // Compute the edge's middle point using the full path, so users can use
    // it to position their custom labels
    var index = Math.floor(fullPath.length / 2);
    var middlePoint = fullPath[index];
    var middleX = middlePoint[0],
      middleY = middlePoint[1];
    var _gridToGraphPoint = gridToGraphPoint({
        x: middleX,
        y: middleY
      }, graphBox.xMin, graphBox.yMin, gridRatio),
      edgeCenterX = _gridToGraphPoint.x,
      edgeCenterY = _gridToGraphPoint.y;
    return {
      svgPathString: svgPathString,
      edgeCenterX: edgeCenterX,
      edgeCenterY: edgeCenterY
    };
  } catch (_unused) {
    return null;
  }
};

var _excluded = ["nodes", "options"];
function SmartEdge(_ref) {
  var nodes = _ref.nodes,
    options = _ref.options,
    edgeProps = _objectWithoutPropertiesLoose(_ref, _excluded);
  var sourceX = edgeProps.sourceX,
    sourceY = edgeProps.sourceY,
    sourcePosition = edgeProps.sourcePosition,
    targetX = edgeProps.targetX,
    targetY = edgeProps.targetY,
    targetPosition = edgeProps.targetPosition,
    style = edgeProps.style,
    label = edgeProps.label,
    labelStyle = edgeProps.labelStyle,
    labelShowBg = edgeProps.labelShowBg,
    labelBgStyle = edgeProps.labelBgStyle,
    labelBgPadding = edgeProps.labelBgPadding,
    labelBgBorderRadius = edgeProps.labelBgBorderRadius,
    markerEnd = edgeProps.markerEnd,
    markerStart = edgeProps.markerStart,
    interactionWidth = edgeProps.interactionWidth;
  var smartResponse = getSmartEdge({
    sourcePosition: sourcePosition,
    targetPosition: targetPosition,
    sourceX: sourceX,
    sourceY: sourceY,
    targetX: targetX,
    targetY: targetY,
    options: options,
    nodes: nodes
  });
  var FallbackEdge = options.fallback || reactflow.BezierEdge;
  if (smartResponse === null) {
    return React__default["default"].createElement(FallbackEdge, _extends({}, edgeProps));
  }
  var edgeCenterX = smartResponse.edgeCenterX,
    edgeCenterY = smartResponse.edgeCenterY,
    svgPathString = smartResponse.svgPathString;
  return React__default["default"].createElement(reactflow.BaseEdge, {
    path: svgPathString,
    labelX: edgeCenterX,
    labelY: edgeCenterY,
    label: label,
    labelStyle: labelStyle,
    labelShowBg: labelShowBg,
    labelBgStyle: labelBgStyle,
    labelBgPadding: labelBgPadding,
    labelBgBorderRadius: labelBgBorderRadius,
    style: style,
    markerStart: markerStart,
    markerEnd: markerEnd,
    interactionWidth: interactionWidth
  });
}

var BezierConfiguration = {
  drawEdge: svgDrawSmoothLinePath,
  generatePath: pathfindingAStarDiagonal,
  fallback: reactflow.BezierEdge
};
function SmartBezierEdge(props) {
  var nodes = reactflow.useNodes();
  return React__default["default"].createElement(SmartEdge, _extends({}, props, {
    options: BezierConfiguration,
    nodes: nodes
  }));
}

var StepConfiguration = {
  drawEdge: svgDrawStraightLinePath,
  generatePath: pathfindingJumpPointNoDiagonal,
  fallback: reactflow.StepEdge
};
function SmartStepEdge(props) {
  var nodes = reactflow.useNodes();
  return React__default["default"].createElement(SmartEdge, _extends({}, props, {
    options: StepConfiguration,
    nodes: nodes
  }));
}

var StraightConfiguration = {
  drawEdge: svgDrawStraightLinePath,
  generatePath: pathfindingAStarNoDiagonal,
  fallback: reactflow.StraightEdge
};
function SmartStraightEdge(props) {
  var nodes = reactflow.useNodes();
  return React__default["default"].createElement(SmartEdge, _extends({}, props, {
    options: StraightConfiguration,
    nodes: nodes
  }));
}

exports.SmartBezierEdge = SmartBezierEdge;
exports.SmartEdge = SmartEdge;
exports.SmartStepEdge = SmartStepEdge;
exports.SmartStraightEdge = SmartStraightEdge;
exports["default"] = SmartBezierEdge;
exports.getSmartEdge = getSmartEdge;
exports.pathfindingAStarDiagonal = pathfindingAStarDiagonal;
exports.pathfindingAStarNoDiagonal = pathfindingAStarNoDiagonal;
exports.pathfindingJumpPointNoDiagonal = pathfindingJumpPointNoDiagonal;
exports.svgDrawSmoothLinePath = svgDrawSmoothLinePath;
exports.svgDrawStraightLinePath = svgDrawStraightLinePath;
//# sourceMappingURL=react-flow-smart-edge.cjs.development.js.map
